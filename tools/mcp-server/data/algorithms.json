{
  "algorithms": [
    {
      "id": "bubble-sort",
      "name": "Bubble Sort",
      "koreanName": "버블 정렬",
      "category": "sorting",
      "purpose": "인접 요소를 비교하며 정렬",
      "timeComplexity": { "best": "O(n)", "average": "O(n²)", "worst": "O(n²)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["안정 정렬", "제자리 정렬", "단순 구현"],
      "advantages": ["구현이 매우 간단", "추가 메모리 불필요", "안정 정렬"],
      "disadvantages": ["매우 느림", "대규모 데이터에 부적합"],
      "useCases": ["교육용", "거의 정렬된 데이터", "소규모 데이터"],
      "difficulty": "LOW",
      "frequency": 2,
      "relatedAlgorithms": ["selection-sort", "insertion-sort"]
    },
    {
      "id": "selection-sort",
      "name": "Selection Sort",
      "koreanName": "선택 정렬",
      "category": "sorting",
      "purpose": "최솟값을 찾아 앞에서부터 정렬",
      "timeComplexity": { "best": "O(n²)", "average": "O(n²)", "worst": "O(n²)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["제자리 정렬", "불안정 정렬", "단순 구현"],
      "advantages": ["구현이 간단", "교환 횟수 최소"],
      "disadvantages": ["항상 O(n²)"],
      "useCases": ["교육용", "작은 데이터셋"],
      "difficulty": "LOW",
      "frequency": 2,
      "relatedAlgorithms": ["bubble-sort", "insertion-sort"]
    },
    {
      "id": "insertion-sort",
      "name": "Insertion Sort",
      "koreanName": "삽입 정렬",
      "category": "sorting",
      "purpose": "각 요소를 적절한 위치에 삽입",
      "timeComplexity": { "best": "O(n)", "average": "O(n²)", "worst": "O(n²)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["안정 정렬", "제자리 정렬", "온라인 알고리즘"],
      "advantages": ["거의 정렬된 데이터에서 빠름", "안정 정렬", "적응적"],
      "disadvantages": ["무작위 데이터에서 느림"],
      "useCases": ["작은 데이터셋", "거의 정렬된 데이터", "Tim Sort의 기반"],
      "difficulty": "LOW",
      "frequency": 3,
      "relatedAlgorithms": ["bubble-sort", "shell-sort"]
    },
    {
      "id": "quick-sort",
      "name": "Quick Sort",
      "koreanName": "퀵 정렬",
      "category": "sorting",
      "purpose": "피벗을 기준으로 분할 정복 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n²)" },
      "spaceComplexity": "O(log n)",
      "characteristics": ["분할 정복", "제자리 정렬", "불안정 정렬"],
      "advantages": ["평균적으로 가장 빠름", "캐시 효율적", "메모리 효율적"],
      "disadvantages": ["최악의 경우 O(n²)", "불안정 정렬"],
      "useCases": ["범용 정렬", "대규모 데이터", "시스템 정렬 라이브러리"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["merge-sort", "heap-sort"]
    },
    {
      "id": "merge-sort",
      "name": "Merge Sort",
      "koreanName": "병합 정렬",
      "category": "sorting",
      "purpose": "배열을 분할하고 병합하여 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["분할 정복", "안정 정렬", "일관된 성능"],
      "advantages": ["항상 O(n log n) 보장", "안정 정렬", "연결 리스트에 효율적"],
      "disadvantages": ["추가 메모리 O(n) 필요"],
      "useCases": ["안정 정렬 필요 시", "연결 리스트 정렬", "외부 정렬"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["quick-sort", "tim-sort"]
    },
    {
      "id": "heap-sort",
      "name": "Heap Sort",
      "koreanName": "힙 정렬",
      "category": "sorting",
      "purpose": "힙 자료구조를 이용한 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["힙 기반", "제자리 정렬", "불안정 정렬"],
      "advantages": ["항상 O(n log n) 보장", "추가 메모리 불필요"],
      "disadvantages": ["캐시 비효율적", "불안정 정렬"],
      "useCases": ["메모리 제한 환경", "우선순위 큐"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["quick-sort", "merge-sort"]
    },
    {
      "id": "counting-sort",
      "name": "Counting Sort",
      "koreanName": "계수 정렬",
      "category": "sorting",
      "purpose": "값의 빈도를 세어 정렬",
      "timeComplexity": { "best": "O(n+k)", "average": "O(n+k)", "worst": "O(n+k)" },
      "spaceComplexity": "O(k)",
      "characteristics": ["비교 기반 아님", "안정 정렬", "정수 범위 제한"],
      "advantages": ["선형 시간", "안정 정렬"],
      "disadvantages": ["정수만 가능", "범위가 크면 비효율적"],
      "useCases": ["정수 정렬", "Radix Sort의 기반"],
      "difficulty": "LOW",
      "frequency": 3,
      "relatedAlgorithms": ["radix-sort", "bucket-sort"]
    },
    {
      "id": "radix-sort",
      "name": "Radix Sort",
      "koreanName": "기수 정렬",
      "category": "sorting",
      "purpose": "자릿수별로 정렬",
      "timeComplexity": { "best": "O(nk)", "average": "O(nk)", "worst": "O(nk)" },
      "spaceComplexity": "O(n+k)",
      "characteristics": ["비교 기반 아님", "안정 정렬", "자릿수 기반"],
      "advantages": ["정수에 효율적", "선형 시간"],
      "disadvantages": ["정수/문자열만 가능"],
      "useCases": ["정수/문자열 정렬", "고정 길이 키"],
      "difficulty": "MEDIUM",
      "frequency": 3,
      "relatedAlgorithms": ["counting-sort", "bucket-sort"]
    },
    {
      "id": "bucket-sort",
      "name": "Bucket Sort",
      "koreanName": "버킷 정렬",
      "category": "sorting",
      "purpose": "범위를 버킷으로 나누어 정렬",
      "timeComplexity": { "best": "O(n+k)", "average": "O(n+k)", "worst": "O(n²)" },
      "spaceComplexity": "O(n+k)",
      "characteristics": ["분산 정렬", "버킷 내부 정렬 필요"],
      "advantages": ["균등 분포에서 빠름"],
      "disadvantages": ["분포에 따라 성능 차이"],
      "useCases": ["균등 분포 데이터", "부동 소수점"],
      "difficulty": "MEDIUM",
      "frequency": 2,
      "relatedAlgorithms": ["counting-sort", "radix-sort"]
    },
    {
      "id": "shell-sort",
      "name": "Shell Sort",
      "koreanName": "셸 정렬",
      "category": "sorting",
      "purpose": "간격을 줄여가며 삽입 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n^1.3)", "worst": "O(n²)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["삽입 정렬 개선", "제자리 정렬", "불안정 정렬"],
      "advantages": ["삽입 정렬보다 빠름", "적응적"],
      "disadvantages": ["간격 선택에 따라 성능 변동"],
      "useCases": ["중간 크기 배열"],
      "difficulty": "MEDIUM",
      "frequency": 2,
      "relatedAlgorithms": ["insertion-sort"]
    },
    {
      "id": "tim-sort",
      "name": "Tim Sort",
      "koreanName": "팀 정렬",
      "category": "sorting",
      "purpose": "병합 정렬 + 삽입 정렬의 하이브리드",
      "timeComplexity": { "best": "O(n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["하이브리드", "안정 정렬", "적응적"],
      "advantages": ["실제 데이터에 최적화", "안정 정렬", "적응적"],
      "disadvantages": ["구현 복잡"],
      "useCases": ["Python/Java 기본 정렬", "실제 데이터"],
      "difficulty": "HIGH",
      "frequency": 5,
      "relatedAlgorithms": ["merge-sort", "insertion-sort"]
    },
    {
      "id": "intro-sort",
      "name": "Intro Sort",
      "koreanName": "인트로 정렬",
      "category": "sorting",
      "purpose": "퀵 정렬 + 힙 정렬 + 삽입 정렬의 하이브리드",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(log n)",
      "characteristics": ["하이브리드", "최악 보장", "불안정 정렬"],
      "advantages": ["최악 O(n log n) 보장"],
      "disadvantages": ["구현 복잡"],
      "useCases": ["C++ STL sort()"],
      "difficulty": "HIGH",
      "frequency": 4,
      "relatedAlgorithms": ["quick-sort", "heap-sort"]
    },
    {
      "id": "tree-sort",
      "name": "Tree Sort",
      "koreanName": "트리 정렬",
      "category": "sorting",
      "purpose": "BST를 이용한 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n²)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["BST 기반", "중위 순회로 정렬"],
      "advantages": ["동적 데이터에 적합"],
      "disadvantages": ["트리 불균형 시 느림"],
      "useCases": ["동적 데이터", "연속 삽입/삭제"],
      "difficulty": "MEDIUM",
      "frequency": 2,
      "relatedAlgorithms": ["heap-sort"]
    },
    {
      "id": "linear-search",
      "name": "Linear Search",
      "koreanName": "선형 탐색",
      "category": "searching",
      "purpose": "처음부터 끝까지 순차적으로 검색",
      "timeComplexity": { "best": "O(1)", "average": "O(n)", "worst": "O(n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["가장 단순한 탐색", "정렬 불필요"],
      "advantages": ["구현이 매우 간단", "전처리 불필요"],
      "disadvantages": ["대규모 데이터에서 비효율적"],
      "useCases": ["소규모 데이터", "정렬되지 않은 데이터"],
      "difficulty": "LOW",
      "frequency": 3,
      "relatedAlgorithms": ["binary-search"]
    },
    {
      "id": "binary-search",
      "name": "Binary Search",
      "koreanName": "이진 탐색",
      "category": "searching",
      "purpose": "정렬된 배열에서 중간값 비교로 탐색 범위 절반씩 축소",
      "timeComplexity": { "best": "O(1)", "average": "O(log n)", "worst": "O(log n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["분할 정복", "정렬된 배열 필수", "매우 효율적"],
      "advantages": ["O(log n) 시간 복잡도", "대규모 데이터에 효율적"],
      "disadvantages": ["정렬된 배열 필요", "연결 리스트에서 비효율적"],
      "useCases": ["정렬된 배열 검색", "Lower/Upper Bound 찾기", "이분 탐색 문제"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["linear-search", "ternary-search"]
    },
    {
      "id": "jump-search",
      "name": "Jump Search",
      "koreanName": "점프 탐색",
      "category": "searching",
      "purpose": "블록 단위로 점프하며 탐색 후 선형 탐색",
      "timeComplexity": { "best": "O(1)", "average": "O(√n)", "worst": "O(√n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["Linear와 Binary의 중간", "블록 크기는 √n이 최적"],
      "advantages": ["Binary Search보다 후진 이동 적음"],
      "disadvantages": ["Binary Search보다 느림"],
      "useCases": ["후진 이동이 비싼 시스템"],
      "difficulty": "LOW",
      "frequency": 1,
      "relatedAlgorithms": ["binary-search", "linear-search"]
    },
    {
      "id": "interpolation-search",
      "name": "Interpolation Search",
      "koreanName": "보간 탐색",
      "category": "searching",
      "purpose": "값의 위치를 추정하여 탐색",
      "timeComplexity": { "best": "O(1)", "average": "O(log log n)", "worst": "O(n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["균등 분포 데이터에 최적", "Binary Search의 개선"],
      "advantages": ["균등 분포 시 매우 빠름"],
      "disadvantages": ["불균등 분포 시 O(n)"],
      "useCases": ["균등하게 분포된 정렬 데이터", "사전 검색"],
      "difficulty": "MEDIUM",
      "frequency": 1,
      "relatedAlgorithms": ["binary-search"]
    },
    {
      "id": "exponential-search",
      "name": "Exponential Search",
      "koreanName": "지수 탐색",
      "category": "searching",
      "purpose": "지수적으로 범위를 확장 후 Binary Search",
      "timeComplexity": { "best": "O(1)", "average": "O(log n)", "worst": "O(log n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["무한 배열에 적합", "타겟이 앞쪽에 있으면 빠름"],
      "advantages": ["무한/대규모 배열에 효과적"],
      "disadvantages": ["Binary Search보다 약간 느림"],
      "useCases": ["무한 배열", "크기를 모르는 정렬 배열"],
      "difficulty": "MEDIUM",
      "frequency": 2,
      "relatedAlgorithms": ["binary-search"]
    },
    {
      "id": "fibonacci-search",
      "name": "Fibonacci Search",
      "koreanName": "피보나치 탐색",
      "category": "searching",
      "purpose": "피보나치 수열을 이용한 분할 탐색",
      "timeComplexity": { "best": "O(1)", "average": "O(log n)", "worst": "O(log n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["Binary Search의 변형", "곱셈/나눗셈 대신 덧셈/뺄셈 사용"],
      "advantages": ["곱셈/나눗셈 없이 구현 가능"],
      "disadvantages": ["구현이 복잡"],
      "useCases": ["하드웨어 최적화", "곱셈이 비싼 시스템"],
      "difficulty": "MEDIUM",
      "frequency": 1,
      "relatedAlgorithms": ["binary-search"]
    },
    {
      "id": "ternary-search",
      "name": "Ternary Search",
      "koreanName": "삼진 탐색",
      "category": "searching",
      "purpose": "배열을 3등분하여 탐색",
      "timeComplexity": { "best": "O(1)", "average": "O(log3 n)", "worst": "O(log3 n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["Binary Search의 변형", "Unimodal 함수의 최대/최소값 찾기에 유용"],
      "advantages": ["최대/최소값 찾기에 유용"],
      "disadvantages": ["일반 검색은 Binary Search가 더 효율적"],
      "useCases": ["Unimodal 함수의 극값 찾기", "최적화 문제"],
      "difficulty": "MEDIUM",
      "frequency": 2,
      "relatedAlgorithms": ["binary-search"]
    },
    {
      "id": "hash-table-search",
      "name": "Hash Table Search",
      "koreanName": "해시 테이블 탐색",
      "category": "searching",
      "purpose": "해시 함수로 직접 위치 계산",
      "timeComplexity": { "best": "O(1)", "average": "O(1)", "worst": "O(n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["키-값 매핑", "충돌 처리 필요", "상수 시간 접근"],
      "advantages": ["평균 O(1) 검색", "삽입/삭제도 O(1)"],
      "disadvantages": ["추가 메모리 필요", "해시 충돌 처리 필요"],
      "useCases": ["데이터베이스 인덱싱", "캐싱", "중복 검사"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["binary-search"]
    },
    {
      "id": "bfs",
      "name": "Breadth-First Search",
      "koreanName": "너비 우선 탐색",
      "category": "graph",
      "purpose": "시작 정점에서 가까운 정점부터 탐색",
      "timeComplexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["큐 사용", "레벨 순서 탐색", "최단 경로 보장 (무가중치)"],
      "advantages": ["최단 경로 찾기에 적합", "목표가 가까우면 빠름"],
      "disadvantages": ["메모리 사용량 많음", "가중치 그래프에서는 최단 경로 보장 안됨"],
      "useCases": ["최단 경로 (무가중치)", "소셜 네트워크", "웹 크롤링"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["dfs", "dijkstra"]
    },
    {
      "id": "dfs",
      "name": "Depth-First Search",
      "koreanName": "깊이 우선 탐색",
      "category": "graph",
      "purpose": "한 경로를 끝까지 탐색 후 백트래킹",
      "timeComplexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["스택/재귀 사용", "깊이 방향 탐색", "경로 탐색에 적합"],
      "advantages": ["메모리 효율적", "경로 존재 여부 확인에 적합"],
      "disadvantages": ["최단 경로 보장 안됨", "무한 루프 가능성"],
      "useCases": ["미로 탐색", "위상 정렬", "사이클 검출"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["bfs", "topological-sort"]
    },
    {
      "id": "dijkstra",
      "name": "Dijkstra's Algorithm",
      "koreanName": "다익스트라",
      "category": "graph",
      "purpose": "단일 출발점에서 모든 정점까지의 최단 경로 (양수 가중치)",
      "timeComplexity": { "best": "O(E log V)", "average": "O(E log V)", "worst": "O(V²)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["우선순위 큐 사용", "그리디 알고리즘", "음수 가중치 불가"],
      "advantages": ["효율적인 최단 경로 계산", "양수 가중치에서 정확한 결과"],
      "disadvantages": ["음수 가중치 처리 불가", "우선순위 큐 필요"],
      "useCases": ["GPS 내비게이션", "네트워크 라우팅", "지도 서비스"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["bellman-ford", "a-star", "floyd-warshall"]
    },
    {
      "id": "bellman-ford",
      "name": "Bellman-Ford Algorithm",
      "koreanName": "벨만-포드",
      "category": "graph",
      "purpose": "단일 출발점에서 모든 정점까지의 최단 경로 (음수 가중치 허용)",
      "timeComplexity": { "best": "O(VE)", "average": "O(VE)", "worst": "O(VE)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["음수 가중치 허용", "음수 사이클 검출 가능", "V-1번 반복"],
      "advantages": ["음수 가중치 처리 가능", "음수 사이클 검출"],
      "disadvantages": ["Dijkstra보다 느림"],
      "useCases": ["음수 가중치 그래프", "차익 거래 감지", "네트워크 라우팅"],
      "difficulty": "MEDIUM",
      "frequency": 3,
      "relatedAlgorithms": ["dijkstra", "spfa"]
    },
    {
      "id": "a-star",
      "name": "A* Search",
      "koreanName": "A* 탐색",
      "category": "graph",
      "purpose": "휴리스틱을 이용한 효율적인 경로 탐색",
      "timeComplexity": { "best": "O(E)", "average": "O(E)", "worst": "O(V²)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["f(n) = g(n) + h(n)", "휴리스틱 기반", "최적 경로 보장"],
      "advantages": ["Dijkstra보다 빠름", "최단 경로 보장"],
      "disadvantages": ["휴리스틱 설계 필요", "메모리 사용량"],
      "useCases": ["게임 AI 경로 찾기", "로봇 내비게이션", "지도 서비스"],
      "difficulty": "HIGH",
      "frequency": 4,
      "relatedAlgorithms": ["dijkstra", "bfs"]
    },
    {
      "id": "floyd-warshall",
      "name": "Floyd-Warshall Algorithm",
      "koreanName": "플로이드-워셜",
      "category": "graph",
      "purpose": "모든 정점 쌍 간의 최단 경로",
      "timeComplexity": { "best": "O(V³)", "average": "O(V³)", "worst": "O(V³)" },
      "spaceComplexity": "O(V²)",
      "characteristics": ["동적 프로그래밍", "모든 쌍 최단 경로", "음수 가중치 허용"],
      "advantages": ["구현이 간단", "모든 쌍 한번에 계산"],
      "disadvantages": ["O(V³) 시간 복잡도", "큰 그래프에서 비효율적"],
      "useCases": ["모든 쌍 최단 경로", "그래프 도달 가능성", "전이 폐쇄"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["dijkstra", "johnson"]
    },
    {
      "id": "prim",
      "name": "Prim's Algorithm",
      "koreanName": "프림 알고리즘",
      "category": "graph",
      "purpose": "최소 신장 트리(MST) 구성",
      "timeComplexity": { "best": "O(E log V)", "average": "O(E log V)", "worst": "O(E log V)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["정점 기반 MST", "우선순위 큐 사용", "밀집 그래프에 적합"],
      "advantages": ["밀집 그래프에서 효율적", "하나의 트리에서 시작"],
      "disadvantages": ["희소 그래프에서 Kruskal보다 느림"],
      "useCases": ["네트워크 설계", "클러스터링", "근사 TSP"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["kruskal", "dijkstra"]
    },
    {
      "id": "kruskal",
      "name": "Kruskal's Algorithm",
      "koreanName": "크루스칼 알고리즘",
      "category": "graph",
      "purpose": "최소 신장 트리(MST) 구성",
      "timeComplexity": { "best": "O(E log E)", "average": "O(E log E)", "worst": "O(E log E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["간선 기반 MST", "Union-Find 사용", "희소 그래프에 적합"],
      "advantages": ["희소 그래프에서 효율적", "구현이 직관적"],
      "disadvantages": ["간선 정렬 필요"],
      "useCases": ["네트워크 설계", "이미지 분할", "클러스터링"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["prim", "union-find"]
    },
    {
      "id": "topological-sort",
      "name": "Topological Sort",
      "koreanName": "위상 정렬",
      "category": "graph",
      "purpose": "DAG의 정점을 선형 순서로 정렬",
      "timeComplexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["DAG에서만 가능", "의존성 순서 결정", "여러 유효한 순서 가능"],
      "advantages": ["의존성 해결에 적합", "선형 시간 복잡도"],
      "disadvantages": ["DAG에서만 사용 가능"],
      "useCases": ["빌드 시스템", "작업 스케줄링", "과목 선수 과목 결정"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["dfs", "bfs"]
    },
    {
      "id": "tarjan-scc",
      "name": "Tarjan's SCC",
      "koreanName": "타잔 강결합 요소",
      "category": "graph",
      "purpose": "방향 그래프에서 강결합 요소(SCC) 찾기",
      "timeComplexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["DFS 기반", "단일 패스로 SCC 탐지", "low-link 값 활용"],
      "advantages": ["효율적인 SCC 탐지", "한 번의 DFS로 완료"],
      "disadvantages": ["구현이 복잡"],
      "useCases": ["소셜 네트워크 분석", "2-SAT 문제", "데드락 감지"],
      "difficulty": "HIGH",
      "frequency": 3,
      "relatedAlgorithms": ["kosaraju", "dfs"]
    },
    {
      "id": "kosaraju",
      "name": "Kosaraju's Algorithm",
      "koreanName": "코사라주 알고리즘",
      "category": "graph",
      "purpose": "방향 그래프에서 강결합 요소(SCC) 찾기",
      "timeComplexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["두 번의 DFS 사용", "역방향 그래프 활용", "이해하기 쉬운 구조"],
      "advantages": ["구현이 직관적", "이해하기 쉬움"],
      "disadvantages": ["두 번의 DFS 필요", "역방향 그래프 구성 필요"],
      "useCases": ["SCC 찾기", "그래프 축약"],
      "difficulty": "MEDIUM",
      "frequency": 2,
      "relatedAlgorithms": ["tarjan-scc", "dfs"]
    },
    {
      "id": "johnson",
      "name": "Johnson's Algorithm",
      "koreanName": "존슨 알고리즘",
      "category": "graph",
      "purpose": "희소 그래프에서 모든 쌍 최단 경로 (음수 가중치 허용)",
      "timeComplexity": { "best": "O(V²logV+VE)", "average": "O(V²logV+VE)", "worst": "O(V²logV+VE)" },
      "spaceComplexity": "O(V²)",
      "characteristics": ["Bellman-Ford + Dijkstra 조합", "가중치 재조정으로 음수 제거"],
      "advantages": ["희소 그래프에서 Floyd-Warshall보다 빠름", "음수 가중치 허용"],
      "disadvantages": ["구현이 복잡", "밀집 그래프에서는 비효율적"],
      "useCases": ["희소 그래프의 모든 쌍 최단 경로", "음수 가중치가 있는 네트워크"],
      "difficulty": "HIGH",
      "frequency": 2,
      "relatedAlgorithms": ["floyd-warshall", "bellman-ford", "dijkstra"]
    },
    {
      "id": "fibonacci-dp",
      "name": "Fibonacci DP",
      "koreanName": "피보나치 DP",
      "category": "dynamic-programming",
      "purpose": "피보나치 수열의 n번째 값을 효율적으로 계산",
      "timeComplexity": { "best": "O(n)", "average": "O(n)", "worst": "O(n)" },
      "spaceComplexity": "O(n) 또는 O(1)",
      "characteristics": ["DP 기본 예시", "메모이제이션/타뷸레이션", "중복 계산 제거"],
      "advantages": ["지수 시간을 선형 시간으로 개선", "DP 입문에 적합"],
      "disadvantages": ["단순한 문제에서는 오버헤드"],
      "useCases": ["피보나치 수열", "계단 오르기 문제", "타일링 문제"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["lis", "lcs"]
    },
    {
      "id": "lcs",
      "name": "Longest Common Subsequence",
      "koreanName": "최장 공통 부분 수열",
      "category": "dynamic-programming",
      "purpose": "두 문자열의 가장 긴 공통 부분 수열 찾기",
      "timeComplexity": { "best": "O(mn)", "average": "O(mn)", "worst": "O(mn)" },
      "spaceComplexity": "O(mn)",
      "characteristics": ["2차원 DP 테이블", "부분 수열은 연속일 필요 없음"],
      "advantages": ["문자열 비교에 효과적", "diff 도구의 기반"],
      "disadvantages": ["긴 문자열에서 메모리 사용량"],
      "useCases": ["diff 도구", "DNA 서열 비교", "파일 비교"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["lis", "edit-distance"]
    },
    {
      "id": "lis",
      "name": "Longest Increasing Subsequence",
      "koreanName": "최장 증가 부분 수열",
      "category": "dynamic-programming",
      "purpose": "가장 긴 증가하는 부분 수열 찾기",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["부분 수열은 연속일 필요 없음", "이진 탐색으로 최적화 가능"],
      "advantages": ["O(n log n) 최적화 가능", "다양한 문제에 응용"],
      "disadvantages": ["O(n²) 기본 구현은 느림"],
      "useCases": ["주식 투자 전략", "박스 쌓기 문제", "최적 스케줄링"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["lcs", "binary-search"]
    },
    {
      "id": "knapsack",
      "name": "Knapsack Problem",
      "koreanName": "배낭 문제",
      "category": "dynamic-programming",
      "purpose": "제한된 용량에서 최대 가치 선택",
      "timeComplexity": { "best": "O(nW)", "average": "O(nW)", "worst": "O(nW)" },
      "spaceComplexity": "O(nW)",
      "characteristics": ["0/1 배낭 문제", "무한 배낭 문제", "NP-Hard 유사 다항 시간"],
      "advantages": ["최적 부분 구조", "다양한 최적화 문제에 적용"],
      "disadvantages": ["큰 용량에서 메모리 사용"],
      "useCases": ["자원 할당", "투자 포트폴리오", "화물 적재"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["coin-change", "subset-sum"]
    },
    {
      "id": "edit-distance",
      "name": "Edit Distance",
      "koreanName": "편집 거리",
      "category": "dynamic-programming",
      "purpose": "한 문자열을 다른 문자열로 변환하는 최소 연산 수",
      "timeComplexity": { "best": "O(mn)", "average": "O(mn)", "worst": "O(mn)" },
      "spaceComplexity": "O(mn)",
      "characteristics": ["삽입/삭제/치환 연산", "LCS와 관련", "Levenshtein Distance"],
      "advantages": ["문자열 유사도 측정", "오타 교정에 활용"],
      "disadvantages": ["긴 문자열에서 느림"],
      "useCases": ["맞춤법 검사", "DNA 서열 정렬", "자연어 처리"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["lcs", "hamming-distance"]
    },
    {
      "id": "matrix-chain",
      "name": "Matrix Chain Multiplication",
      "koreanName": "행렬 체인 곱셈",
      "category": "dynamic-programming",
      "purpose": "행렬 곱셈 순서를 최적화하여 최소 연산 수 계산",
      "timeComplexity": { "best": "O(n³)", "average": "O(n³)", "worst": "O(n³)" },
      "spaceComplexity": "O(n²)",
      "characteristics": ["괄호화 최적화", "구간 DP의 대표 문제"],
      "advantages": ["연산 비용 최소화", "다양한 최적화 문제에 응용"],
      "disadvantages": ["구현이 복잡"],
      "useCases": ["행렬 계산 최적화", "파서 최적화", "다각형 삼각분할"],
      "difficulty": "HIGH",
      "frequency": 3,
      "relatedAlgorithms": ["knapsack", "optimal-bst"]
    },
    {
      "id": "coin-change",
      "name": "Coin Change",
      "koreanName": "동전 교환",
      "category": "dynamic-programming",
      "purpose": "주어진 금액을 만드는 최소 동전 수 또는 방법 수",
      "timeComplexity": { "best": "O(nS)", "average": "O(nS)", "worst": "O(nS)" },
      "spaceComplexity": "O(S)",
      "characteristics": ["무한 배낭 문제의 변형", "최소 개수 또는 조합 수"],
      "advantages": ["효율적인 해법", "다양한 변형 가능"],
      "disadvantages": ["큰 금액에서 메모리 사용"],
      "useCases": ["거스름돈 계산", "환전", "자원 분배"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["knapsack", "rod-cutting"]
    },
    {
      "id": "rod-cutting",
      "name": "Rod Cutting",
      "koreanName": "막대 자르기",
      "category": "dynamic-programming",
      "purpose": "막대를 잘라서 최대 이익 얻기",
      "timeComplexity": { "best": "O(n²)", "average": "O(n²)", "worst": "O(n²)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["무한 배낭 문제의 변형", "분할 최적화 문제"],
      "advantages": ["최적 분할 전략 도출", "직관적인 DP 적용"],
      "disadvantages": ["큰 길이에서 시간 증가"],
      "useCases": ["재료 절단 최적화", "자원 분배"],
      "difficulty": "MEDIUM",
      "frequency": 3,
      "relatedAlgorithms": ["knapsack", "coin-change"]
    },
    {
      "id": "kmp",
      "name": "KMP Algorithm",
      "koreanName": "KMP 알고리즘",
      "category": "string",
      "purpose": "패턴 문자열을 텍스트에서 효율적으로 검색",
      "timeComplexity": { "best": "O(n+m)", "average": "O(n+m)", "worst": "O(n+m)" },
      "spaceComplexity": "O(m)",
      "characteristics": ["실패 함수 사용", "중복 비교 없음"],
      "advantages": ["선형 시간 보장", "전처리로 효율적 검색"],
      "disadvantages": ["실패 함수 이해 어려움"],
      "useCases": ["텍스트 편집기 검색", "DNA 서열 매칭", "문서 검색"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["rabin-karp", "boyer-moore"]
    },
    {
      "id": "trie",
      "name": "Trie",
      "koreanName": "트라이",
      "category": "string",
      "purpose": "문자열 집합의 효율적인 저장과 검색",
      "timeComplexity": { "best": "O(m)", "average": "O(m)", "worst": "O(m)" },
      "spaceComplexity": "O(ALPHABET * n * m)",
      "characteristics": ["접두사 트리", "공통 접두사 공유"],
      "advantages": ["빠른 검색 및 접두사 매칭", "자동 완성에 적합"],
      "disadvantages": ["메모리 사용량 많음"],
      "useCases": ["자동 완성", "사전 구현", "IP 라우팅"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["suffix-tree", "aho-corasick"]
    },
    {
      "id": "euclidean-gcd",
      "name": "Euclidean GCD",
      "koreanName": "유클리드 최대공약수",
      "category": "math",
      "purpose": "두 수의 최대공약수 계산",
      "timeComplexity": { "best": "O(1)", "average": "O(log min(a,b))", "worst": "O(log min(a,b))" },
      "spaceComplexity": "O(1)",
      "characteristics": ["가장 오래된 알고리즘", "나눗셈 기반"],
      "advantages": ["매우 효율적", "구현 간단"],
      "disadvantages": ["큰 수에서 오버플로우 주의"],
      "useCases": ["분수 약분", "암호학 (RSA)", "모듈러 역원"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["extended-gcd", "lcm"]
    },
    {
      "id": "sieve-eratosthenes",
      "name": "Sieve of Eratosthenes",
      "koreanName": "에라토스테네스의 체",
      "category": "math",
      "purpose": "특정 범위 내 모든 소수 찾기",
      "timeComplexity": { "best": "O(n log log n)", "average": "O(n log log n)", "worst": "O(n log log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["고대 그리스 알고리즘", "배수 제거 방식"],
      "advantages": ["매우 효율적", "구현 간단"],
      "disadvantages": ["메모리 사용량"],
      "useCases": ["소수 목록 생성", "소인수분해", "암호학"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["miller-rabin", "prime-factorization"]
    },
    {
      "id": "n-queens",
      "name": "N-Queens",
      "koreanName": "N-퀸",
      "category": "backtracking",
      "purpose": "N×N 체스판에 N개의 퀸을 서로 공격하지 않게 배치",
      "timeComplexity": { "best": "O(N!)", "average": "O(N!)", "worst": "O(N!)" },
      "spaceComplexity": "O(N)",
      "characteristics": ["대표적인 백트래킹 문제", "행 단위로 퀸 배치"],
      "advantages": ["가지치기로 탐색 공간 축소", "다양한 최적화 가능"],
      "disadvantages": ["지수적 시간 복잡도"],
      "useCases": ["조합 최적화", "제약 만족 문제", "스케줄링"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["sudoku-solver", "graph-coloring"]
    },
    {
      "id": "huffman",
      "name": "Huffman Coding",
      "koreanName": "허프만 코딩",
      "category": "greedy",
      "purpose": "가변 길이 접두사 코드로 데이터 압축",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["빈도 기반 최적 코딩", "접두사 자유 코드"],
      "advantages": ["최적 압축률", "무손실 압축"],
      "disadvantages": ["코드 테이블 저장 필요"],
      "useCases": ["파일 압축 (ZIP, GZIP)", "JPEG 이미지 압축", "데이터 전송"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["shannon-fano", "arithmetic-coding"]
    },
    {
      "id": "strassen-matrix",
      "name": "Strassen's Matrix Multiplication",
      "koreanName": "스트라센 행렬 곱셈",
      "category": "divide-conquer",
      "purpose": "행렬 곱셈을 더 빠르게 수행",
      "timeComplexity": { "best": "O(n^2.807)", "average": "O(n^2.807)", "worst": "O(n^2.807)" },
      "spaceComplexity": "O(n²)",
      "characteristics": ["7번의 곱셈으로 2×2 행렬 곱 수행", "일반적인 8번 → 7번으로 감소"],
      "advantages": ["큰 행렬에서 효율적", "이론적으로 중요"],
      "disadvantages": ["작은 행렬에서 오버헤드", "수치적 불안정성"],
      "useCases": ["대규모 행렬 연산", "과학 계산", "컴퓨터 그래픽스"],
      "difficulty": "HIGH",
      "frequency": 1,
      "relatedAlgorithms": ["matrix-chain"]
    },
    {
      "id": "closest-pair",
      "name": "Closest Pair of Points",
      "koreanName": "최근접 점 쌍",
      "category": "divide-conquer",
      "purpose": "2D 평면에서 가장 가까운 두 점 찾기",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["분할 정복으로 O(n log n) 달성", "Brute Force O(n²)보다 효율적"],
      "advantages": ["효율적인 기하 알고리즘", "실제 응용에 유용"],
      "disadvantages": ["구현이 복잡"],
      "useCases": ["충돌 감지", "클러스터링", "컴퓨터 그래픽스"],
      "difficulty": "HIGH",
      "frequency": 2,
      "relatedAlgorithms": ["convex-hull"]
    },
    {
      "id": "karatsuba",
      "name": "Karatsuba Multiplication",
      "koreanName": "카라츠바 곱셈",
      "category": "divide-conquer",
      "purpose": "큰 정수의 곱셈을 효율적으로 수행",
      "timeComplexity": { "best": "O(n^1.585)", "average": "O(n^1.585)", "worst": "O(n^1.585)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["3번의 곱셈으로 계산", "일반적인 4번 → 3번으로 감소"],
      "advantages": ["큰 수 곱셈에 효율적", "분할 정복의 좋은 예"],
      "disadvantages": ["작은 수에서 오버헤드"],
      "useCases": ["암호학", "대수 시스템", "임의 정밀도 연산"],
      "difficulty": "HIGH",
      "frequency": 2,
      "relatedAlgorithms": ["fft"]
    }
  ],
  "categories": {
    "sorting": {
      "name": "정렬 알고리즘",
      "description": "데이터를 특정 순서로 재배열하는 알고리즘",
      "algorithms": ["bubble-sort", "selection-sort", "insertion-sort", "merge-sort", "quick-sort", "heap-sort", "counting-sort", "radix-sort", "bucket-sort", "shell-sort", "tim-sort", "intro-sort", "tree-sort"]
    },
    "searching": {
      "name": "탐색 알고리즘",
      "description": "데이터 집합에서 특정 값을 찾는 알고리즘",
      "algorithms": ["linear-search", "binary-search", "jump-search", "interpolation-search", "exponential-search", "fibonacci-search", "ternary-search", "hash-table-search"]
    },
    "graph": {
      "name": "그래프 알고리즘",
      "description": "그래프 자료구조에서 탐색, 최단 경로, MST 등을 구하는 알고리즘",
      "algorithms": ["bfs", "dfs", "dijkstra", "bellman-ford", "floyd-warshall", "a-star", "prim", "kruskal", "topological-sort", "tarjan-scc", "kosaraju", "johnson"]
    },
    "dynamic-programming": {
      "name": "동적 프로그래밍",
      "description": "복잡한 문제를 작은 부분 문제로 나누어 해결하고 결과를 재사용하는 알고리즘",
      "algorithms": ["fibonacci-dp", "lcs", "lis", "knapsack", "edit-distance", "matrix-chain", "coin-change", "rod-cutting"]
    },
    "divide-conquer": {
      "name": "분할 정복",
      "description": "문제를 작은 부분 문제로 분할하고 결과를 결합하는 알고리즘",
      "algorithms": ["strassen-matrix", "closest-pair", "karatsuba"]
    },
    "greedy": {
      "name": "탐욕 알고리즘",
      "description": "각 단계에서 지역적으로 최적인 선택을 하여 전체 최적해를 구하는 알고리즘",
      "algorithms": ["huffman"]
    },
    "backtracking": {
      "name": "백트래킹",
      "description": "가능한 모든 해를 탐색하면서 조건을 만족하지 않으면 되돌아가는 알고리즘",
      "algorithms": ["n-queens"]
    },
    "string": {
      "name": "문자열 알고리즘",
      "description": "문자열 검색, 매칭, 처리를 위한 알고리즘",
      "algorithms": ["kmp", "trie"]
    },
    "math": {
      "name": "수학 알고리즘",
      "description": "수학적 연산과 수론 문제를 해결하는 알고리즘",
      "algorithms": ["euclidean-gcd", "sieve-eratosthenes"]
    }
  }
}
