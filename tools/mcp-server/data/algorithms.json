{
  "algorithms": [
    {
      "id": "bubble-sort",
      "name": "Bubble Sort",
      "koreanName": "버블 정렬",
      "category": "sorting",
      "purpose": "인접 요소를 비교하며 정렬",
      "timeComplexity": { "best": "O(n)", "average": "O(n²)", "worst": "O(n²)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["안정 정렬", "제자리 정렬", "단순 구현"],
      "advantages": ["구현이 매우 간단", "추가 메모리 불필요", "안정 정렬"],
      "disadvantages": ["매우 느림", "대규모 데이터에 부적합"],
      "useCases": ["교육용", "거의 정렬된 데이터", "소규모 데이터"],
      "difficulty": "LOW",
      "frequency": 2,
      "relatedAlgorithms": ["selection-sort", "insertion-sort"]
    },
    {
      "id": "quick-sort",
      "name": "Quick Sort",
      "koreanName": "퀵 정렬",
      "category": "sorting",
      "purpose": "피벗을 기준으로 분할 정복 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n²)" },
      "spaceComplexity": "O(log n)",
      "characteristics": ["분할 정복", "제자리 정렬", "불안정 정렬"],
      "advantages": ["평균적으로 가장 빠름", "캐시 효율적", "메모리 효율적"],
      "disadvantages": ["최악의 경우 O(n²)", "불안정 정렬"],
      "useCases": ["범용 정렬", "대규모 데이터", "시스템 정렬 라이브러리"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["merge-sort", "heap-sort"]
    },
    {
      "id": "merge-sort",
      "name": "Merge Sort",
      "koreanName": "병합 정렬",
      "category": "sorting",
      "purpose": "배열을 분할하고 병합하여 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["분할 정복", "안정 정렬", "일관된 성능"],
      "advantages": ["항상 O(n log n) 보장", "안정 정렬", "연결 리스트에 효율적"],
      "disadvantages": ["추가 메모리 O(n) 필요"],
      "useCases": ["안정 정렬 필요 시", "연결 리스트 정렬", "외부 정렬"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["quick-sort", "tim-sort"]
    },
    {
      "id": "heap-sort",
      "name": "Heap Sort",
      "koreanName": "힙 정렬",
      "category": "sorting",
      "purpose": "힙 자료구조를 이용한 정렬",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["힙 기반", "제자리 정렬", "불안정 정렬"],
      "advantages": ["항상 O(n log n) 보장", "추가 메모리 불필요"],
      "disadvantages": ["캐시 비효율적", "불안정 정렬"],
      "useCases": ["메모리 제한 환경", "우선순위 큐"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["quick-sort", "merge-sort"]
    },
    {
      "id": "binary-search",
      "name": "Binary Search",
      "koreanName": "이진 탐색",
      "category": "searching",
      "purpose": "정렬된 배열에서 중간값 비교로 탐색 범위 절반씩 축소",
      "timeComplexity": { "best": "O(1)", "average": "O(log n)", "worst": "O(log n)" },
      "spaceComplexity": "O(1)",
      "characteristics": ["분할 정복", "정렬된 배열 필수", "매우 효율적"],
      "advantages": ["O(log n) 시간 복잡도", "대규모 데이터에 효율적"],
      "disadvantages": ["정렬된 배열 필요", "연결 리스트에서 비효율적"],
      "useCases": ["정렬된 배열 검색", "Lower/Upper Bound 찾기", "이분 탐색 문제"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["linear-search", "ternary-search"]
    },
    {
      "id": "bfs",
      "name": "Breadth-First Search",
      "koreanName": "너비 우선 탐색",
      "category": "graph",
      "purpose": "시작 정점에서 가까운 정점부터 탐색",
      "timeComplexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["큐 사용", "레벨 순서 탐색", "최단 경로 보장 (무가중치)"],
      "advantages": ["최단 경로 찾기에 적합", "목표가 가까우면 빠름"],
      "disadvantages": ["메모리 사용량 많음", "가중치 그래프에서는 최단 경로 보장 안됨"],
      "useCases": ["최단 경로 (무가중치)", "소셜 네트워크", "웹 크롤링"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["dfs", "dijkstra"]
    },
    {
      "id": "dfs",
      "name": "Depth-First Search",
      "koreanName": "깊이 우선 탐색",
      "category": "graph",
      "purpose": "한 경로를 끝까지 탐색 후 백트래킹",
      "timeComplexity": { "best": "O(V+E)", "average": "O(V+E)", "worst": "O(V+E)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["스택/재귀 사용", "깊이 방향 탐색", "경로 탐색에 적합"],
      "advantages": ["메모리 효율적", "경로 존재 여부 확인에 적합"],
      "disadvantages": ["최단 경로 보장 안됨", "무한 루프 가능성"],
      "useCases": ["미로 탐색", "위상 정렬", "사이클 검출"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["bfs", "topological-sort"]
    },
    {
      "id": "dijkstra",
      "name": "Dijkstra's Algorithm",
      "koreanName": "다익스트라",
      "category": "graph",
      "purpose": "단일 출발점에서 모든 정점까지의 최단 경로 (양수 가중치)",
      "timeComplexity": { "best": "O(E log V)", "average": "O(E log V)", "worst": "O(V²)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["우선순위 큐 사용", "그리디 알고리즘", "음수 가중치 불가"],
      "advantages": ["효율적인 최단 경로 계산", "양수 가중치에서 정확한 결과"],
      "disadvantages": ["음수 가중치 처리 불가", "우선순위 큐 필요"],
      "useCases": ["GPS 내비게이션", "네트워크 라우팅", "지도 서비스"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["bellman-ford", "a-star", "floyd-warshall"]
    },
    {
      "id": "bellman-ford",
      "name": "Bellman-Ford Algorithm",
      "koreanName": "벨만-포드",
      "category": "graph",
      "purpose": "단일 출발점에서 모든 정점까지의 최단 경로 (음수 가중치 허용)",
      "timeComplexity": { "best": "O(VE)", "average": "O(VE)", "worst": "O(VE)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["음수 가중치 허용", "음수 사이클 검출 가능", "V-1번 반복"],
      "advantages": ["음수 가중치 처리 가능", "음수 사이클 검출"],
      "disadvantages": ["Dijkstra보다 느림"],
      "useCases": ["음수 가중치 그래프", "차익 거래 감지", "네트워크 라우팅"],
      "difficulty": "MEDIUM",
      "frequency": 3,
      "relatedAlgorithms": ["dijkstra", "spfa"]
    },
    {
      "id": "a-star",
      "name": "A* Search",
      "koreanName": "A* 탐색",
      "category": "graph",
      "purpose": "휴리스틱을 이용한 효율적인 경로 탐색",
      "timeComplexity": { "best": "O(E)", "average": "O(E)", "worst": "O(V²)" },
      "spaceComplexity": "O(V)",
      "characteristics": ["f(n) = g(n) + h(n)", "휴리스틱 기반", "최적 경로 보장"],
      "advantages": ["Dijkstra보다 빠름", "최단 경로 보장"],
      "disadvantages": ["휴리스틱 설계 필요", "메모리 사용량"],
      "useCases": ["게임 AI 경로 찾기", "로봇 내비게이션", "지도 서비스"],
      "difficulty": "HIGH",
      "frequency": 4,
      "relatedAlgorithms": ["dijkstra", "bfs"]
    },
    {
      "id": "floyd-warshall",
      "name": "Floyd-Warshall Algorithm",
      "koreanName": "플로이드-워셜",
      "category": "graph",
      "purpose": "모든 정점 쌍 간의 최단 경로",
      "timeComplexity": { "best": "O(V³)", "average": "O(V³)", "worst": "O(V³)" },
      "spaceComplexity": "O(V²)",
      "characteristics": ["동적 프로그래밍", "모든 쌍 최단 경로", "음수 가중치 허용"],
      "advantages": ["구현이 간단", "모든 쌍 한번에 계산"],
      "disadvantages": ["O(V³) 시간 복잡도", "큰 그래프에서 비효율적"],
      "useCases": ["모든 쌍 최단 경로", "그래프 도달 가능성", "전이 폐쇄"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["dijkstra", "johnson"]
    },
    {
      "id": "lcs",
      "name": "Longest Common Subsequence",
      "koreanName": "최장 공통 부분 수열",
      "category": "dynamic-programming",
      "purpose": "두 문자열의 가장 긴 공통 부분 수열 찾기",
      "timeComplexity": { "best": "O(mn)", "average": "O(mn)", "worst": "O(mn)" },
      "spaceComplexity": "O(mn)",
      "characteristics": ["2차원 DP 테이블", "부분 수열은 연속일 필요 없음"],
      "advantages": ["문자열 비교에 효과적", "diff 도구의 기반"],
      "disadvantages": ["긴 문자열에서 메모리 사용량"],
      "useCases": ["diff 도구", "DNA 서열 비교", "파일 비교"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["lis", "edit-distance"]
    },
    {
      "id": "knapsack",
      "name": "Knapsack Problem",
      "koreanName": "배낭 문제",
      "category": "dynamic-programming",
      "purpose": "제한된 용량에서 최대 가치 선택",
      "timeComplexity": { "best": "O(nW)", "average": "O(nW)", "worst": "O(nW)" },
      "spaceComplexity": "O(nW)",
      "characteristics": ["0/1 배낭 문제", "무한 배낭 문제", "NP-Hard 유사 다항 시간"],
      "advantages": ["최적 부분 구조", "다양한 최적화 문제에 적용"],
      "disadvantages": ["큰 용량에서 메모리 사용"],
      "useCases": ["자원 할당", "투자 포트폴리오", "화물 적재"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["coin-change", "subset-sum"]
    },
    {
      "id": "kmp",
      "name": "KMP Algorithm",
      "koreanName": "KMP 알고리즘",
      "category": "string",
      "purpose": "패턴 문자열을 텍스트에서 효율적으로 검색",
      "timeComplexity": { "best": "O(n+m)", "average": "O(n+m)", "worst": "O(n+m)" },
      "spaceComplexity": "O(m)",
      "characteristics": ["실패 함수 사용", "중복 비교 없음"],
      "advantages": ["선형 시간 보장", "전처리로 효율적 검색"],
      "disadvantages": ["실패 함수 이해 어려움"],
      "useCases": ["텍스트 편집기 검색", "DNA 서열 매칭", "문서 검색"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["rabin-karp", "boyer-moore"]
    },
    {
      "id": "trie",
      "name": "Trie",
      "koreanName": "트라이",
      "category": "string",
      "purpose": "문자열 집합의 효율적인 저장과 검색",
      "timeComplexity": { "best": "O(m)", "average": "O(m)", "worst": "O(m)" },
      "spaceComplexity": "O(ALPHABET * n * m)",
      "characteristics": ["접두사 트리", "공통 접두사 공유"],
      "advantages": ["빠른 검색 및 접두사 매칭", "자동 완성에 적합"],
      "disadvantages": ["메모리 사용량 많음"],
      "useCases": ["자동 완성", "사전 구현", "IP 라우팅"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["suffix-tree", "aho-corasick"]
    },
    {
      "id": "euclidean-gcd",
      "name": "Euclidean GCD",
      "koreanName": "유클리드 최대공약수",
      "category": "math",
      "purpose": "두 수의 최대공약수 계산",
      "timeComplexity": { "best": "O(1)", "average": "O(log min(a,b))", "worst": "O(log min(a,b))" },
      "spaceComplexity": "O(1)",
      "characteristics": ["가장 오래된 알고리즘", "나눗셈 기반"],
      "advantages": ["매우 효율적", "구현 간단"],
      "disadvantages": ["큰 수에서 오버플로우 주의"],
      "useCases": ["분수 약분", "암호학 (RSA)", "모듈러 역원"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["extended-gcd", "lcm"]
    },
    {
      "id": "sieve-eratosthenes",
      "name": "Sieve of Eratosthenes",
      "koreanName": "에라토스테네스의 체",
      "category": "math",
      "purpose": "특정 범위 내 모든 소수 찾기",
      "timeComplexity": { "best": "O(n log log n)", "average": "O(n log log n)", "worst": "O(n log log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["고대 그리스 알고리즘", "배수 제거 방식"],
      "advantages": ["매우 효율적", "구현 간단"],
      "disadvantages": ["메모리 사용량"],
      "useCases": ["소수 목록 생성", "소인수분해", "암호학"],
      "difficulty": "LOW",
      "frequency": 5,
      "relatedAlgorithms": ["miller-rabin", "prime-factorization"]
    },
    {
      "id": "n-queens",
      "name": "N-Queens",
      "koreanName": "N-퀸",
      "category": "backtracking",
      "purpose": "N×N 체스판에 N개의 퀸을 서로 공격하지 않게 배치",
      "timeComplexity": { "best": "O(N!)", "average": "O(N!)", "worst": "O(N!)" },
      "spaceComplexity": "O(N)",
      "characteristics": ["대표적인 백트래킹 문제", "행 단위로 퀸 배치"],
      "advantages": ["가지치기로 탐색 공간 축소", "다양한 최적화 가능"],
      "disadvantages": ["지수적 시간 복잡도"],
      "useCases": ["조합 최적화", "제약 만족 문제", "스케줄링"],
      "difficulty": "MEDIUM",
      "frequency": 4,
      "relatedAlgorithms": ["sudoku-solver", "graph-coloring"]
    },
    {
      "id": "huffman",
      "name": "Huffman Coding",
      "koreanName": "허프만 코딩",
      "category": "greedy",
      "purpose": "가변 길이 접두사 코드로 데이터 압축",
      "timeComplexity": { "best": "O(n log n)", "average": "O(n log n)", "worst": "O(n log n)" },
      "spaceComplexity": "O(n)",
      "characteristics": ["빈도 기반 최적 코딩", "접두사 자유 코드"],
      "advantages": ["최적 압축률", "무손실 압축"],
      "disadvantages": ["코드 테이블 저장 필요"],
      "useCases": ["파일 압축 (ZIP, GZIP)", "JPEG 이미지 압축", "데이터 전송"],
      "difficulty": "MEDIUM",
      "frequency": 5,
      "relatedAlgorithms": ["shannon-fano", "arithmetic-coding"]
    }
  ],
  "categories": {
    "sorting": {
      "name": "정렬 알고리즘",
      "description": "데이터를 특정 순서로 재배열하는 알고리즘",
      "algorithms": ["bubble-sort", "selection-sort", "insertion-sort", "merge-sort", "quick-sort", "heap-sort", "counting-sort", "radix-sort", "bucket-sort", "shell-sort", "tim-sort", "intro-sort", "tree-sort"]
    },
    "searching": {
      "name": "탐색 알고리즘",
      "description": "데이터 집합에서 특정 값을 찾는 알고리즘",
      "algorithms": ["linear-search", "binary-search", "jump-search", "interpolation-search", "exponential-search", "fibonacci-search", "ternary-search", "hash-search"]
    },
    "graph": {
      "name": "그래프 알고리즘",
      "description": "그래프 자료구조에서 탐색, 최단 경로, MST 등을 구하는 알고리즘",
      "algorithms": ["bfs", "dfs", "dijkstra", "bellman-ford", "floyd-warshall", "a-star", "prim", "kruskal", "topological-sort", "tarjan-scc", "kosaraju", "johnson"]
    },
    "dynamic-programming": {
      "name": "동적 프로그래밍",
      "description": "복잡한 문제를 작은 부분 문제로 나누어 해결하고 결과를 재사용하는 알고리즘",
      "algorithms": ["fibonacci-dp", "lcs", "lis", "knapsack", "edit-distance", "matrix-chain", "coin-change", "rod-cutting"]
    },
    "divide-conquer": {
      "name": "분할 정복",
      "description": "문제를 작은 부분 문제로 분할하고 결과를 결합하는 알고리즘",
      "algorithms": ["binary-search-dc", "merge-sort-dc", "strassen", "closest-pair", "karatsuba"]
    },
    "greedy": {
      "name": "탐욕 알고리즘",
      "description": "각 단계에서 지역적으로 최적인 선택을 하여 전체 최적해를 구하는 알고리즘",
      "algorithms": ["activity-selection", "huffman", "fractional-knapsack", "job-sequencing", "optimal-merge"]
    },
    "backtracking": {
      "name": "백트래킹",
      "description": "가능한 모든 해를 탐색하면서 조건을 만족하지 않으면 되돌아가는 알고리즘",
      "algorithms": ["n-queens", "sudoku-solver", "graph-coloring", "hamiltonian-cycle", "subset-sum"]
    },
    "string": {
      "name": "문자열 알고리즘",
      "description": "문자열 검색, 매칭, 처리를 위한 알고리즘",
      "algorithms": ["kmp", "rabin-karp", "boyer-moore", "z-algorithm", "suffix-array", "trie", "aho-corasick"]
    },
    "math": {
      "name": "수학 알고리즘",
      "description": "수학적 연산과 수론 문제를 해결하는 알고리즘",
      "algorithms": ["euclidean-gcd", "sieve-eratosthenes", "fast-exponentiation", "modular-arithmetic", "chinese-remainder", "fft", "simpson-integration", "newton-raphson", "prime-factorization", "miller-rabin"]
    }
  }
}
